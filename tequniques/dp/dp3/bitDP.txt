n個の要素の順列n!を探索するときにn*2^nまで減らせる(条件により[]を増やすともうちょい上)
bit DP フレームワークでは、以下のような漸化式が成立することが多い:

dp[S] = min_{i∈S} {dp[S-{i}] + cost(S\{i}, i)}
S についてその中で順序を最適化したときのコストdp[S]を計算したい.
その順序の最後の要素がなんだったかで場合分け:

S の最後が i だったとき- S の最後の i を除いた部分集合についての最適解は dp[S - {i}].
S - {i} に i を加えて増えるコストを cost(S \ {i}, i) とする.
結局最小コストは dp[S - {i}] + cost(S - {i}, i).

初期値: dp[0] = 0
出力: dp[(1 << n) - 1]
